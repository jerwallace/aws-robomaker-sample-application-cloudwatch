#!/usr/bin/env python

import rospy
import rostest
import time
import os
import unittest

from rosgraph_msgs.msg import Clock
from ros_monitoring_msgs.msg import MetricList
from robomaker_simulation_msgs.msg import Tag
from robomaker_simulation_msgs.srv import Cancel, AddTags

METRIC_NAME = "distance_to_goal"

class SimulationUtils():
    """
    This class provides methods to interact with the robomaker simulation service. You can cancel jobs and tag jobs.
    """
    def __init__(self):
        self.is_cancelled = False
        
    def cancel_job(self):
        rospy.wait_for_service('/robomaker/job/cancel')
        requestCancel = rospy.ServiceProxy('/robomaker/job/cancel', Cancel)
        response = requestCancel()
        if response.success:
            self.is_cancelled = True
            rospy.loginfo("Successfully requested cancel job")
        else:
            rospy.logerr("Cancel request failed: %s", response.message)

    def set_tag(self, name, value):
        rospy.wait_for_service('/robomaker/job/add_tags')
        requestAddTags = rospy.ServiceProxy('/robomaker/job/add_tags', AddTags)
        tags = ([Tag(key=name, value=value)])
        response = requestAddTags(tags)
        if response.success:
            rospy.loginfo("Successfully added tags: %s", tags)
        else:
            rospy.logerr("Add tags request failed for tags (%s): %s", tags, response.message)

class NavigationTest(unittest.TestCase):
    """
    This test case will send a number of expected goals and monitor their status. If the robot reaches all of the destinations, it will mark the test as passed. 
    """    
    def setUp(self):
        self.utils = SimulationUtils()
        self.latch = False
        self.successful_navigations = 0
        self.test_name = "Robot_Monitoring_Tests_" + str(time.time()).split(".", 1)[0]
        self.is_completed = False
        rospy.loginfo("Test Name: %s", self.test_name)
        if rospy.has_param('NAVIGATION_SUCCESS_COUNT'):
            self.navigation_success_count = rospy.get_param('NAVIGATION_SUCCESS_COUNT')
        else:
            self.navigation_success_count = 1

    def set_latched(self):
        self.latch = True
    
    def set_unlatched(self):
        self.latch = False
    
    def increment_navigations(self):
        self.successful_navigations = self.successful_navigations + 1
    
    def is_complete(self):
        if self.successful_navigations >= self.navigation_success_count:
            return True
        else:
            return False
    
    def check_complete(self, msgs):
        for msg in msgs.metrics:
            if msg.metric_name == METRIC_NAME:
                rospy.loginfo("Metric Name: %s", msg.metric_name)
                rospy.loginfo("Metric Value: %s", msg.value)
                if msg.value == 0.0 and self.is_completed == False and self.latch == False:
                    self.set_latched()
                    self.increment_navigations()
                    self.utils.set_tag(name=self.test_name + "_Successful_Nav_" + str(self.successful_navigations), value=str(self.successful_navigations))
                    if self.is_complete():
                        self.is_completed = True
                        self.utils.set_tag(name=self.test_name, value="Passed")
                        self.utils.cancel_job()
                elif msg.value > 1 and self.is_completed == False:
                    self.set_unlatched()
                    
    def test_navigation(self):
    	try:
    		self.utils.set_tag(name=self.test_name + "_Time_Elapsed_Start", value= str(time.time()).split(".", 1)[0])
    		self.clock = rospy.Subscriber('/metrics', MetricList, self.check_complete)
    		rospy.spin()
    	except:
            self.utils.set_tag(name=self.test_name + "_Time_Elapsed_Status", value="Failed")
            self.utils.cancel_job()

    def runTest(self):
        self.test_navigation()

if __name__ == "__main__":
    rospy.init_node('navigation_test', log_level=rospy.INFO)
    rostest.rosrun('test_node', 'navigation_test', NavigationTest)
    
    